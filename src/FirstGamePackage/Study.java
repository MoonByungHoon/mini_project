package FirstGamePackage;

 

/*public*/ class Study {
/* 위에 주석처리한 것을보면 public은 생략이 가능하며 생략할 경우 기본값(default)인 default가 자동으로 적용된다.
 * 이런 것들을 접근제어자 라고 하는데 종류는 private default protected public이 있다.
 * private는 본인이 존재하고 있는 해당 클래스 내에서만 접근이 가능하며,
 * default는 본인이 존재하고 있는 같은 패키지 내에서만 접근이 가능하며,
 * protected는 본인이 존재하고 있는 패키지와 상속받은 다른 패키지에서 접근이 가능하며,
 * public은 어디서든 접근이 가능하다.
 * 
 * 하나의 파일에서 하나의 클래스만 쓰는 이유는 JAVA에는 5가지 원칙이 있는데 이를 solid라고 한다.
 * 이 solid는 개발자간의 업무 능력을 향상시키기 위한 원칙인데 이중에 S에 해당하는 단일 책임 원칙이 그러한 이유이다.이게 SRP  Single Responsibility Principal네 이거요 흠.. 
 * 하나의 클래스는 하나의 책임만 가지는것을 말하는데 여기서 하나의 책임이란 하나의 목적만을 가지는 것을 말한다.
 * 
 *	(접근제어자) Study() {
 * 		이 구조는 생성자의 기본구조이다. 생성자를 따로 생성 하지 않을때에 이러한 구조가 자동으로 적용된다.
 * 		생성자의 조건은 클래스와 동일한 이름을 가지고 있으며 값을 반환하지 않는 목적의 메소드에서 적는 void를 적지 않으며, 
 * 		생성자는 Scanner sc = new Scanner; 처럼 new를 붙여서 클래스의 인스턴스생성과 동시에 같이 호출되어진다. 
 *  }
*/
	
	private int i, j, k;
/* 		메인이 아닌 클래스에서 일반적으로 변수에 private를 거는 이유는 보안의 문제도 있으나 툴을 사용하다보면
 * 		추천 사용 리스트를 자주 쓰게 되는데 이것을 쓸때에 리스트 노출을 줄이는 용도도 된다. 
 * 		즉 코딩을 진행함에 있어서 직관성도 좋아지고 코딩 속도도 빠르게 증가 시킬 수 있다. 
 */
	
/*	getter setter라고 하는 구조이다. 이는 초기에는 없던 구조이고 개발자들이 private를 쓰면서 해당 변수에 접근을
 * 	용이하게 하고 관리를 쉽게 하기 위함으로 상용된 것으로 안다. 이는 목적이 분명한 메소드의 이름을 활용하여서
 * 	데이터의 접근과 관리 직관성을 높이는 것으로 solid의 O에 해당하는 개방폐쇄 원칙에 해당한다.
 * 	getset메서드를 보게 되면 메서드에 대한 이해가 올라갈 수 있다.
 */
	
	public int getI() {
	//여기서의 int는 되돌려주는 타입을 컴퓨터에게 알려주는 것이다. 하나의 타입만 돌려줄 수 있다.
		return i;
/*	여기서의 return은 되돌려줄 것을 나타내는데 변수가 될 수도 있고 숫자나 문자열이 될 수 있고,
 * 	메서드를 적을수도 있다. 메서드를 적게되면 해당 메서드를 호출하는 의미가 되어서 적은 메서드 내부를 동작하게 하는데,
 *	void 메서드는 호출이 불가하다. 이유는 리턴을 만난다는건 현재 위치에서 더이상의 동작이 없음을 의미하는데
 *	void는 리턴이 없는 단순히 동작을 마치면 다시 이전 위치로 돌아오게 되는데 돌아올 경우 해당 메소드가 동작을 마친 상태라
 *	더이상 진행할게 없어지므로 이 경우 잘못된 코딩이 되서이다.
 *	(return을 이해하기에 조금 쉽게 이해하자면 메소드를 적을 경우에는 html에서 클릭시 링크의 주소를 잡아주고 넘기는 것을 생각하면 이해가 빠르다.) 		
*/
	}

	public void setI(int i) {
	//void는 돌려주는 값이 없다는 것을 의미한다. 이러한 메소드들은 호출과 동시에 해당 메소드 내부의 동작을 시작하고
	//종료하는 시점에 자신을 호출했던 위치로 되돌아간다.
		this.i = i;
	//this는 자신이 속한 { } 중괄호 밖에 있는 존재중에 가장 가까운 대상을 목표로 삼는다.
	//여기서는 Study 클래스 내에 선언된 int i를 가리키고 있다.
	}

	public int getJ() {
		return j;
	}

	public void setJ(int j) {
		this.j = j;
	}

	public int getK() {
		return k;
	}

	public void setK(int k) {
		this.k = k;
	}
	
	
}